/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const ParserHelpers = require("./ParserHelpers");
const ConstDependency = require("./dependencies/ConstDependency");
const RuleSet = require("./RuleSet");
const NullFactory = require("./NullFactory");
const Uuid = require("uuid");

class ProvidePlugin {
	constructor(definitions, params) {
		this.definitions = definitions;
		this.identity = Uuid.v4();
		params = params || {};
		if(params.test || params.exclude || params.include) {
			this.condition = RuleSet.normalizeCondition({
				exclude: params.exclude,
				include: params.include,
				test: params.test
			});
		}
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.plugin("normal-module-factory", (nmf) => {
			nmf.plugin("after-resolve", (data, done) => {
				let identities = this._getActiveProvidePlugins(data);
				data.parser = nmf.getParser({
					activeProvidePlugins: identities
				});
				this._saveActiveProvidePluginsToParser(data.parser, identities);
				done(null, data);
			});
		});
		compiler.plugin("compilation", (compilation, params) => {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
			params.normalModuleFactory.plugin("parser", (parser, parserOptions) => {
				if(!this._isEnabledForParserOptions(parserOptions)) {
					return;
				}
				Object.keys(definitions).forEach(name => {
					var request = [].concat(definitions[name]);
					var splittedName = name.split(".");
					if(splittedName.length > 0) {
						splittedName.slice(1).forEach((_, i) => {
							const name = splittedName.slice(0, i + 1).join(".");
							parser.plugin(`can-rename ${name}`, ParserHelpers.approve);
						});
					}
					parser.plugin(`expression ${name}`, function(expr) {
						let nameIdentifier = name;
						const scopedName = name.indexOf(".") >= 0;
						let expression = `require(${JSON.stringify(request[0])})`;
						if(scopedName) {
							nameIdentifier = `__webpack_provided_${name.replace(/\./g, "_dot_")}`;
						}
						if(request.length > 1) {
							expression += request.slice(1).map(r => `[${JSON.stringify(r)}]`).join("");
						}
						if(!ParserHelpers.addParsedVariableToModule(this, nameIdentifier, expression)) {
							return false;
						}
						if(scopedName) {
							ParserHelpers.toConstantDependency(nameIdentifier).bind(this)(expr);
						}
						return true;
					});
				});
			});
		});
	}

	/**
	 * Extracts the UUIDs of provide plugins that are active for the current request. This includes the UUIDs of all
	 * plugins that set themselves up previously, and the UUID of this plugin, if it is to be enabled.
	 *
	 * @private
	 * @param {Map} data - Request data after resolution.
	 * @returns {Array<string>} - The UUIDs of the active provide plugins for this request.
	 */
	_getActiveProvidePlugins(data) {
		const enabled = this._isEnabledForResource(data.resource);
		let activeIdentities = (data.parser.options && data.parser.options.activeProvidePlugins) || [];
		let ownIndex = activeIdentities.indexOf(this.identity);
		if(enabled && ownIndex === -1) {
			activeIdentities = activeIdentities.concat(this.identity);
		} else if(!enabled && ownIndex > -1) {
			activeIdentities = activeIdentities.slice(0, ownIndex).concat(activeIdentities.slice(ownIndex + 1));
		}
		return activeIdentities;
	}

	/**
	 * @private
	 * @param {string} resource - Path of the resource to check.
	 * @returns {boolean} - Whether this plugin instance should be enabled for the mentioned resource.
	 */
	_isEnabledForResource(resource) {
		return !this.condition || this.condition(resource);
	}

	/**
	 * Parser options are transient by default. If multiple provide plugins are instantiated, it is necessary to record
	 * the list of active plugin UUIDs.
	 *
	 * @private
	 * @param {Parser} parser - The parser generated by the normalModuleFactory
	 * @param {Array<string>} identities - The UUIDs of the currently active provide plugins.
	 * @returns {void}
	 */
	_saveActiveProvidePluginsToParser(parser, identities) {
		if(!parser.options) {
			parser.options = {};
		}
		parser.options.activeProvidePlugins = identities || [];
	}

	/**
	 * Examines the parser options to determine whether the plugin should operate on this parse operation.
	 *
	 * @private
	 * @param {Map} parserOptions - The parser options.
	 * @returns {boolean} - Whether imports for variables should be provided.
	 */
	_isEnabledForParserOptions(parserOptions) {
		if(parserOptions && parserOptions.activeProvidePlugins) {
			return parserOptions.activeProvidePlugins.indexOf(this.identity) > -1;
		}
		return false;
	}

}
module.exports = ProvidePlugin;
